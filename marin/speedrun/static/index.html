<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Marin Speedrun - Leaderboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js" defer></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'marin-blue': '#1a73e8',
                        'marin-dark': '#1e293b'
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-gray-50">
    <div class="min-h-screen">
        <header class="bg-marin-dark text-white shadow-lg">
            <div class="container mx-auto px-4 py-6">
                <h1 class="text-3xl font-bold">Marin Speedrun - Leaderboard</h1>
                <p class="mt-2 text-gray-300">Community-driven model training leaderboard</p>
            </div>
        </header>
        <main class="container mx-auto px-4 py-8">
            <div class="mb-8">
                <div class="inline-flex rounded-lg border border-gray-200 bg-white p-1 mb-4">
                    <button class="track-btn px-4 py-2 rounded-md text-sm font-medium active bg-marin-blue text-white" data-track="all">All Tracks</button>
                    <button class="track-btn px-4 py-2 rounded-md text-sm font-medium" data-track="fineweb_edu">FineWeb-Edu</button>
                    <button class="track-btn px-4 py-2 rounded-md text-sm font-medium" data-track="data">Data</button>
                </div>
                <button id="clear-selection" class="px-4 py-2 rounded-md text-sm font-medium bg-gray-200 hover:bg-gray-300" style="display: none;">Clear Selection</button>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                <div class="bg-white rounded-lg shadow p-6">
                    <h3 class="text-lg font-medium mb-4">Total Number of Runs</h3>
                    <div id="total-runs" class="text-2xl font-bold">-</div>
                </div>
                <div class="bg-white rounded-lg shadow p-6">
                    <h3 class="text-lg font-medium mb-4">Best C4-EN BPB</h3>
                    <div id="best-bpb" class="text-2xl font-bold">-</div>
                </div>
            </div>
            <div class="bg-white rounded-lg shadow p-6 mb-8 relative h-96 flex flex-col">
                <h2 class="text-xl font-semibold text-gray-900 mb-4 flex-shrink-0">Pareto Frontier: FLOPs vs. C4-EN BPB</h2>
                <div class="relative flex-grow">
                    <canvas id="pareto-chart" style="position: absolute; top: 0; left: 0; height: 100%; width: 100%;"></canvas>
                    <canvas id="overlay-canvas" style="position: absolute; top: 0; left: 0; height: 100%; width: 100%; pointer-events: none;"></canvas>
                </div>
            </div>
            <div class="bg-white rounded-lg shadow overflow-hidden">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Rank</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Run Name</th>

                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Model Size</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Training Time</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Total FLOPs</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">C4-EN BPB</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Submitted By</th>
                        </tr>
                    </thead>
                    <tbody class="bg-white divide-y divide-gray-200" id="leaderboard-body"></tbody>
                </table>
            </div>
        </main>
    </div>

    <script>
        async function fetchLeaderboard() {
            try {
                const response = await fetch('./data/runs.json');
                const data = await response.json();
                console.log('Loaded data:', data);

                return data.map(entry => ({
                    ...entry,
                    model_size: parseFloat(entry.model_size) || 0,
                    total_training_flops: parseFloat(entry.total_training_flops) || 0,
                    total_training_time: parseFloat(entry.total_training_time) || 0,
                    eval_paloma_c4_en_bpb: entry.eval_paloma_c4_en_bpb != null ? parseFloat(entry.eval_paloma_c4_en_bpb) : null,
                    submitted_by: entry.submitted_by || "unknown",
                    wandb_link: entry.wandb_link || "N/A"
                }));
            } catch (error) {
                console.error("Error fetching leaderboard data:", error);
                return [];
            }
        }

        function formatModelSize(size) {
            if (!size) return "N/A";
            return size < 1e9 ? `${(size / 1e6).toFixed(1)}M` : `${(size / 1e9).toFixed(1)}B`;
        }

        function formatFlops(flops) {
            if (!flops) return "N/A";
            return flops.toExponential(2).replace('e+', 'E');
        }

        function formatMetric(value) {
            return value === null || isNaN(value) ? 'N/A' : value.toFixed(3);
        }

        function updateStats(entries) {
            // Update total runs count
            document.getElementById('total-runs').textContent = entries.length;

            if (entries.length === 0) {
                document.getElementById('best-bpb').textContent = '-';
                return;
            }

            // Find best C4-EN BPB
            const bestBpb = entries.reduce((min, entry) =>
                (entry.eval_paloma_c4_en_bpb && entry.eval_paloma_c4_en_bpb < min) ? entry.eval_paloma_c4_en_bpb : min,
                entries.find(e => e.eval_paloma_c4_en_bpb)?.eval_paloma_c4_en_bpb || Infinity);

            // Update stats display
            document.getElementById('best-bpb').textContent = bestBpb !== Infinity ? bestBpb.toFixed(3) : '-';
        }

        function computeParetoFrontier(entries) {
            if (!entries.length) return [];
            const validEntries = entries.filter(e =>
                e.final_flops_used > 0 &&
                Number.isFinite(e.eval_paloma_c4_en_bpb) &&
                e.eval_paloma_c4_en_bpb > 0
            );
            if (!validEntries.length) return [];
            const sorted = [...validEntries].sort((a, b) => a.final_flops_used - b.final_flops_used);
            const frontier = [];
            let minBPB = Infinity;
            for (const entry of sorted) {
                if (entry.eval_paloma_c4_en_bpb <= minBPB) {
                    frontier.push(entry);
                    minBPB = entry.eval_paloma_c4_en_bpb;
                }
            }
            return frontier;
        }

        function generateSmoothCurve(paretoData) {
            if (paretoData.length < 2) return paretoData;
            const smoothData = [];
            for (let i = 0; i < paretoData.length - 1; i++) {
                const p1 = paretoData[i];
                const p2 = paretoData[i + 1];
                for (let t = 0; t <= 1; t += 0.1) {
                    const x = p1.x + t * (p2.x - p1.x);
                    const y = p1.y + t * (p2.y - p1.y);
                    smoothData.push({ x, y });
                }
            }
            return smoothData;
        }

        let paretoChart = null;
        let selectedRuns = new Set();
        let allEntries = [];
        let currentTrack = 'all';

        let updateTimeout = null;

        function updateParetoChart(entries, track = 'all') {
            if (updateTimeout) clearTimeout(updateTimeout);
            updateTimeout = setTimeout(() => {
                let filteredEntries = entries;

                // Filter by track based on tokenized_dataset field
                if (track === 'fineweb_edu') {
                    filteredEntries = entries.filter(e =>
                        e.tokenized_dataset && e.tokenized_dataset.includes('fineweb-edu'));
                } else if (track === 'data') {
                    filteredEntries = entries.filter(e =>
                        !e.tokenized_dataset || !e.tokenized_dataset.includes('fineweb-edu'));
                }
                const validEntries = filteredEntries.filter(
            e => Number.isFinite(e.final_flops_used) && e.final_flops_used > 0 &&
                 Number.isFinite(e.eval_paloma_c4_en_bpb) && e.eval_paloma_c4_en_bpb > 0
        );
                if (!validEntries.length) {
                    if (paretoChart) {
                        paretoChart.destroy();
                        paretoChart = null;
                    }
                    const ctx = document.getElementById('pareto-chart').getContext('2d');
                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                    return;
                }

                const chartData = validEntries.map(entry => ({
            x: entry.final_flops_used / 1e18,
            y: entry.eval_paloma_c4_en_bpb,
            run_name: entry.run_name,
            track: entry.compute_budget_track
        }));

        const paretoEntries = computeParetoFrontier(validEntries);
        const paretoData = paretoEntries.map(entry => ({
            x: entry.final_flops_used / 1e18,
            y: entry.eval_paloma_c4_en_bpb
        }));

        const smoothCurveData = generateSmoothCurve(paretoData);

        // Calculate data ranges for axis scaling
        const flopsValues = validEntries.map(e => e.final_flops_used / 1e18);
        const bpbValues = validEntries.map(e => e.eval_paloma_c4_en_bpb);
        const minFlops = flopsValues.length ? Math.min(...flopsValues) : 0.1;
        const maxFlops = flopsValues.length ? Math.max(...flopsValues) : 1;
        const minBPB = bpbValues.length ? Math.min(...bpbValues) : 0.1;
        const maxBPB = bpbValues.length ? Math.max(...bpbValues) : 2;

        // Calculate more optimal axis limits with adaptive padding
        const bpbRange = maxBPB - minBPB;
        const flopsRange = maxFlops - minFlops;

        // Use smaller padding for y-axis (BPB) to reduce vertical whitespace
        const yPadding = Math.max(bpbRange * 0.05, 0.001);
        const xPadding = Math.max(flopsRange * 0.1, 0.01);

        const xMin = Math.max(minFlops - xPadding, 0.01);
        const xMax = maxFlops + xPadding;
        const yMin = Math.max(minBPB - yPadding, 0.01);
        const yMax = maxBPB + yPadding;

        if (paretoChart) {
            paretoChart.destroy();
            paretoChart = null;
        }

        const ctx = document.getElementById('pareto-chart').getContext('2d');
        paretoChart = new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: [
                            {
                                label: 'Runs',
                                data: chartData,
                                backgroundColor: validEntries.map(entry => {
                                    if (selectedRuns.size > 0 && !selectedRuns.has(entry.run_name)) {
                                        return 'rgba(200, 200, 200, 0.3)';
                                    }
                                    switch (entry.compute_budget_track) {
                                        case 'TINY': return 'rgba(75, 192, 192, 0.6)';
                                        case 'SMALL': return 'rgba(255, 159, 64, 0.6)';
                                        case 'MEDIUM': return 'rgba(153, 102, 255, 0.6)';
                                        default: return 'rgba(128, 128, 128, 0.6)';
                                    }
                                }),
                                borderColor: validEntries.map(entry => {
                                    if (selectedRuns.size > 0 && !selectedRuns.has(entry.run_name)) {
                                        return 'rgba(200, 200, 200, 0.3)';
                                    }
                                    switch (entry.compute_budget_track) {
                                        case 'TINY': return 'rgba(75, 192, 192, 1)';
                                        case 'SMALL': return 'rgba(255, 159, 64, 1)';
                                        case 'MEDIUM': return 'rgba(153, 102, 255, 1)';
                                        default: return 'rgba(128, 128, 128, 1)';
                                    }
                                }),
                                pointRadius: 6,
                                pointHoverRadius: 8
                            },
                            {
                                label: 'Pareto Frontier',
                                data: paretoData,
                                type: 'line',
                                borderColor: 'rgba(255, 99, 132, 1)',
                                backgroundColor: 'rgba(255, 99, 132, 0.2)',
                                fill: false,
                                pointRadius: 8,
                                pointHoverRadius: 10,
                                showLine: true,
                                tension: 0.1
                            },
                            {
                                label: 'Smoothed Pareto Curve',
                                data: smoothCurveData,
                                type: 'line',
                                borderColor: 'rgba(0, 255, 0, 0.8)',
                                backgroundColor: 'rgba(0, 255, 0, 0.2)',
                                fill: false,
                                pointRadius: 0,
                                showLine: true,
                                tension: 0.4
                            }
                        ]
                    },
                    options: {
                        animation: false,
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: { display: true, text: 'FLOPs Used (ExaFLOPs)' },
                                type: 'logarithmic',
                                position: 'bottom',
                                min: xMin,
                                max: xMax,
                                ticks: { callback: function(value) { return Number(value).toFixed(2); } }
                            },
                            y: {
                                title: { display: true, text: 'C4-EN BPB (lower is better)' },
                                type: 'linear',
                                min: yMin,
                                max: yMax,
                                ticks: { callback: function(value) { return Number(value).toFixed(3); } }
                            }
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const entry = context.raw;
                                        if (context.dataset.label === 'Pareto Frontier' || context.dataset.label === 'Smoothed Pareto Curve') {
                                            return `Pareto Point: ${entry.x.toFixed(2)} EFLOPs, ${entry.y.toFixed(3)} BPB`;
                                        }
                                        return `${entry.run_name} (${entry.track}): ${entry.x.toFixed(2)} EFLOPs, ${entry.y.toFixed(3)} BPB`;
                                    }
                                }
                            },
                            legend: { display: true }
                        }
                    }
                });
            }, 100);
        }

        function updateLeaderboard(entries, track = 'all') {
            allEntries = entries;
            let filteredEntries = entries;

            // Filter by track based on tokenized_dataset field
            if (track === 'fineweb_edu') {
                filteredEntries = entries.filter(e =>
                    e.tokenized_dataset && e.tokenized_dataset.includes('fineweb-edu'));
            } else if (track === 'data') {
                filteredEntries = entries.filter(e =>
                    !e.tokenized_dataset || !e.tokenized_dataset.includes('fineweb-edu'));
            }
            filteredEntries.sort((a, b) => (a.eval_paloma_c4_en_bpb || Infinity) - (b.eval_paloma_c4_en_bpb || Infinity));
            updateStats(filteredEntries);
            updateParetoChart(entries, track);
            const tbody = document.getElementById('leaderboard-body');
            tbody.innerHTML = '';
            filteredEntries.forEach((entry, index) => {
                const row = document.createElement('tr');
                if (selectedRuns.size > 0 && selectedRuns.has(entry.run_name)) {
                    row.className = 'bg-yellow-100';
                } else {
                    row.className = index % 2 === 0 ? 'bg-white' : 'bg-gray-50';
                }
                row.innerHTML = `
                    <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">${index + 1}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-blue-600 hover:text-blue-800 cursor-pointer">
                        <a href="https://github.com/stanford-crfm/marin/tree/main/experiments/speedrun/${entry.run_name}" target="_blank">${entry.run_name}</a>
                    </td>

                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${formatModelSize(entry.model_size)}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${entry.total_training_time.toFixed(1)}m</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${formatFlops(entry.final_flops_used)}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${formatMetric(entry.eval_paloma_c4_en_bpb)}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${entry.submitted_by}</td>
                `;
                tbody.appendChild(row);
            });
        }



        document.querySelectorAll('.track-btn').forEach(button => {
            button.addEventListener('click', async () => {
                document.querySelectorAll('.track-btn').forEach(btn => {
                    btn.classList.remove('active', 'bg-marin-blue', 'text-white');
                });
                button.classList.add('active', 'bg-marin-blue', 'text-white');
                currentTrack = button.dataset.track;
                selectedRuns.clear();
                document.getElementById('clear-selection').style.display = 'none';
                updateLeaderboard(allEntries, currentTrack);
                updateParetoChart(allEntries, currentTrack);
            });
        });

        document.getElementById('clear-selection').addEventListener('click', () => {
            selectedRuns.clear();
            document.getElementById('clear-selection').style.display = 'none';
            updateParetoChart(allEntries, currentTrack);
            updateLeaderboard(allEntries, currentTrack);
        });

        document.addEventListener('DOMContentLoaded', async () => {
            const mainCanvas = document.getElementById('pareto-chart');
            const overlayCanvas = document.getElementById('overlay-canvas');
            mainCanvas.parentElement.style.position = 'relative';
            const resizeOverlay = () => {
                overlayCanvas.width = mainCanvas.width;
                overlayCanvas.height = mainCanvas.height;
                overlayCanvas.style.left = `${mainCanvas.offsetLeft}px`;
                overlayCanvas.style.top = `${mainCanvas.offsetTop}px`;
            };
            resizeOverlay();
            window.addEventListener('resize', resizeOverlay);

            let startX, startY, endX, endY;
            let isDragging = false;

            mainCanvas.onmousedown = (e) => {
                const rect = mainCanvas.getBoundingClientRect();
                startX = e.clientX - rect.left;
                startY = e.clientY - rect.top;
                isDragging = true;
            };

            mainCanvas.onmousemove = (e) => {
                if (!isDragging) return;
                const rect = mainCanvas.getBoundingClientRect();
                endX = e.clientX - rect.left;
                endY = e.clientY - rect.top;
                const ctx = overlayCanvas.getContext('2d');
                ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                ctx.strokeStyle = 'rgba(0, 0, 255, 0.5)';
                ctx.strokeRect(startX, startY, endX - startX, endY - startY);
            };

            mainCanvas.onmouseup = (e) => {
                if (!isDragging) return;
                isDragging = false;
                const rect = mainCanvas.getBoundingRect();
                endX = e.clientX - rect.left;
                endY = e.clientY - rect.top;
                const ctx = overlayCanvas.getContext('2d');
                ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

                const xAxis = paretoChart.scales['x'];
                const yAxis = paretoChart.scales['y'];
                const chartStartX = xAxis.getValueForPixel(startX);
                const chartEndX = xAxis.getValueForPixel(endX);
                const chartStartY = yAxis.getValueForPixel(startY);
                const chartEndY = yAxis.getValueForPixel(endY);

                const selectionMinX = Math.min(chartStartX, chartEndX);
                const selectionMaxX = Math.max(chartStartX, chartEndX);
                const selectionMinY = Math.min(chartStartY, chartEndY);
                const selectionMaxY = Math.max(chartStartY, chartEndY);

                selectedRuns.clear();
                const chartData = allEntries
                    .filter(e => Number.isFinite(e.model_size) && e.model_size > 0 && Number.isFinite(e.final_flops_used) && e.final_flops_used > 0)
                    .map(entry => ({
                        x: entry.model_size / 1e9,
                        y: entry.final_flops_used / 1e18,
                        run_name: entry.run_name
                    }));
                chartData.forEach((point) => {
                    const x = point.x;
                    const y = point.y;
                    if (x >= selectionMinX && x <= selectionMaxX && y >= selectionMinY && y <= selectionMaxY) {
                        selectedRuns.add(point.run_name);
                    }
                });

                updateParetoChart(allEntries, currentTrack);
                updateLeaderboard(allEntries, currentTrack);
                document.getElementById('clear-selection').style.display = selectedRuns.size > 0 ? 'inline-block' : 'none';
            };

            const data = await fetchLeaderboard();
            if (typeof Chart === 'undefined') {
                await new Promise(resolve => {
                    const checkChart = setInterval(() => {
                        if (typeof Chart !== 'undefined') {
                            clearInterval(checkChart);
                            resolve();
                        }
                    }, 100);
                });
            }
            updateLeaderboard(data, currentTrack);
            updateParetoChart(data, currentTrack);
        });
    </script>

    <style>
        .track-btn { transition: all 0.2s; }
        .track-btn:hover { background-color: #e5e7eb; }
        .track-btn.active { background-color: #1a73e8; color: white; }

    </style>
</body>
</html>
